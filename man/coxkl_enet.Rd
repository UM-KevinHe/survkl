% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coxkl_enet.R
\name{coxkl_enet}
\alias{coxkl_enet}
\title{Cox Proportional Hazards Model with KL Divergence for Data Integration and Lasso & Elastic Net Penalty}
\usage{
coxkl_enet(
  z,
  delta,
  time,
  stratum = NULL,
  RS = NULL,
  beta = NULL,
  eta = NULL,
  alpha = NULL,
  lambda = NULL,
  nlambda = 100,
  lambda.min.ratio = ifelse(n < p, 0.05, 0.001),
  lambda.early.stop = FALSE,
  tol = 1e-04,
  Mstop = 1000,
  max.total.iter = (Mstop * nlambda),
  group = 1:ncol(z),
  group.multiplier = NULL,
  standardize = T,
  nvar.max = ncol(z),
  group.max = length(unique(group)),
  stop.loss.ratio = 0.001,
  actSet = TRUE,
  actIter = Mstop,
  actGroupNum = sum(unique(group) != 0),
  actSetRemove = F,
  returnX = FALSE,
  trace.lambda = FALSE,
  message = FALSE,
  data_sorted = FALSE,
  ...
)
}
\arguments{
\item{z}{Numeric matrix of covariates with rows representing observations and
columns representing predictor variables. All covariates must be numeric.}

\item{delta}{Numeric vector of event indicators (1 = event, 0 = censored).}

\item{time}{Numeric vector of observed event or censoring times. No sorting
required.}

\item{stratum}{Optional numeric or factor vector defining strata.}

\item{RS}{Optional numeric vector or matrix of external risk scores. Length
(or number of rows) must equal the number of observations. If not supplied,
\code{beta} must be provided.}

\item{beta}{Optional numeric vector of external coefficients (e.g., from prior
studies). Length must equal the number of columns in \code{z}. Use zeros to
represent covariates without external information. If not supplied, \code{RS}
must be provided.}

\item{eta}{Numeric tuning parameter controlling the reliance on external
information. Larger values place more weight on the external source.}

\item{alpha}{Elastic-net mixing parameter in \eqn{(0,1]}. When \eqn{\alpha=1}
the penalty is lasso.}

\item{lambda}{Optional nonnegative penalty parameter(s). If a numeric vector
is supplied, the path is taken as-is. If \code{NULL}, a sequence is generated
using \code{nlambda} and \code{lambda.min.ratio}.}

\item{nlambda}{Integer number of lambda values to generate when \code{lambda} is
\code{NULL}. Default \code{100}.}

\item{lambda.min.ratio}{Ratio of the smallest to the largest lambda when
generating a sequence (when \code{lambda} is \code{NULL}). Default \code{1e-3}.}

\item{lambda.early.stop}{Logical; if \code{TRUE}, stop traversing the lambda path
early based on convergence or screening criteria. Default \code{FALSE}.}

\item{tol}{Convergence tolerance for the optimization algorithm. Default is
\code{1e-3}.}

\item{Mstop}{Maximum number of iterations for the inner optimization at a
given lambda. Default is \code{1000}.}

\item{max.total.iter}{Maximum total iterations across the entire lambda path.
Default is \code{(Mstop * nlambda)}.}

\item{group}{Integer vector of group indices defining group
membership of predictors for grouped penalties; use \code{0} to indicate
unpenalized variables.}

\item{group.multiplier}{A vector of values representing multiplicative factors
by which each covariate's penalty is to be multiplied. Default is a vector of 1's.}

\item{standardize}{Logical; if \code{TRUE}, columns of \code{z} are standardized prior
to fitting, with coefficients re-scaled on output. Default \code{TRUE}.}

\item{nvar.max}{Integer cap on the number of active variables allowed during
fitting. Default number of predictors.}

\item{group.max}{Integer cap on the number of active groups allowed during
fitting. Default total number of groups.}

\item{stop.loss.ratio}{Relative improvement threshold for early stopping along
the path; optimization may stop if objective gain falls below this value.
Default \code{1e-3}.}

\item{actSet}{Logical; if \code{TRUE}, use an active-set strategy. Default \code{TRUE}.}

\item{actIter}{Maximum number of active-set refinement iterations per lambda.
Default \code{Mstop}.}

\item{actGroupNum}{Maximum number of active groups allowed under the
active-set scheme.}

\item{actSetRemove}{Logical; if \code{TRUE}, allow dropping variables/groups from
the active set during iterations. Default \code{FALSE}.}

\item{returnX}{Logical; if \code{TRUE}, return standardized design and related
internals in \code{result$returnX}. Default \code{FALSE}.}

\item{trace.lambda}{Logical; if \code{TRUE}, record path-wise traces across the
lambda sequence. Default \code{FALSE}.}

\item{message}{Logical; if \code{TRUE}, progress messages are printed during model
fitting. Default is \code{FALSE}.}

\item{data_sorted}{Logical; if \code{TRUE}, input is assumed already sorted by
\code{stratum} then \code{time}. Default \code{FALSE}.}

\item{...}{Additional arguments.}
}
\value{
An object of class \code{"coxkl_enet"}, a list with components:
\describe{
\item{\code{beta}}{Coefficient estimates (vector or matrix across the path).}
\item{\code{group}}{A \code{factor} of the original group assignments.}
\item{\code{lambda}}{The lambda value(s) used or generated.}
\item{\code{alpha}}{The elastic-net mixing parameter used.}
\item{\code{likelihood}}{Vector of log-partial likelihoods for each lambda.}
\item{\code{n}}{Number of observations.}
\item{\code{df}}{Effective degrees of freedom (e.g., number of nonzero
coefficients or group-adjusted count) along the path.}
\item{\code{iter}}{Number of iterations taken (per lambda and/or total).}
\item{\code{W}}{Exponentiated linear predictors on the original scale.}
\item{\code{group.multiplier}}{Group-specific penalty multipliers used.}
\item{\code{returnX}}{Only when \code{returnX = TRUE}: a list with elements
\code{XX} (standardization/orthogonalization info from \code{std.Z}),
\code{time}, \code{delta}, \code{stratum}, and \code{RS}.}
}
}
\description{
Fits a Cox proportional hazards model that incorporates external information
using Kullbackâ€“Leibler (KL) divergence, with an optional L1 (Lasso) or elastic net penalty on
the coefficients. External information can be supplied either as precomputed external
risk scores (\code{RS}) or as externally derived coefficients (\code{beta}). The integration
strength is controlled by the tuning parameter \code{eta}.
}
\details{
Setting \code{lambda = 0} reduces to the unpenalized \code{\link{coxkl}} model.

When \code{lambda > 0}, the model fits a KL-regularized Cox objective with an
elastic-net penalty:
\deqn{\ell_{\mathrm{KL}}(\beta;\eta) \;-\; \lambda\Big\{ \alpha\|\beta\|_1 \;+\; (1-\alpha)\tfrac{1}{2}\|\beta\|_2^2 \Big\},}
where \eqn{\alpha=1} gives lasso and \eqn{0<\alpha<1} gives elastic net. Grouped
penalties are supported via \code{group} (use \code{0} for unpenalized variables), with optional
per-group scaling through \code{group.multiplier}. If \code{lambda} is \code{NULL}, a decreasing path
of length \code{nlambda} is generated using \code{lambda.min.ratio}; early stopping can prune the
path (\code{lambda.early.stop}, \code{stop.loss.ratio}). When \code{standardize = TRUE}, predictors are
standardized for fitting and coefficients are rescaled on output. If \code{data_sorted = FALSE},
data are sorted by \code{stratum} then \code{time} for optimization and predictions are returned in
the original order (reported via \verb{W = exp(linear predictors)}). An active-set scheme
(\code{actSet}, \code{actIter}, \code{nvar.max}, \code{group.max}, \code{actGroupNum}, \code{actSetRemove}) is used to
accelerate the solution along the lambda path.
}
\examples{
data(ExampleData_highdim) 

train_dat_highdim <- ExampleData_highdim$train
beta_external_highdim <- ExampleData_highdim$beta_external

model_enet <- coxkl_enet(z = train_dat_highdim$z,
                         delta = train_dat_highdim$status,
                         time = train_dat_highdim$time,
                         stratum = NULL,
                         RS = NULL,
                         beta = beta_external_highdim,
                         eta = 0,
                         alpha = 1.0,
                         message = TRUE)

}
\seealso{
\code{\link{coxkl}}
}
